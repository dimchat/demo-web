;
// license: https://mit-license.org
//
//  DIMPLES: DIMP Library for Easy Startup
//
//                               Written in 2021 by Moky <albert.moky@gmail.com>
//
// =============================================================================
// The MIT License (MIT)
//
// Copyright (c) 2021 Albert Moky
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// =============================================================================
//

//! require 'common/*.js'

(function (ns) {
    'use strict';

    var Class  = ns.type.Class;
    var Log    = ns.lnc.Log;
    var Thread = ns.fsm.threading.Thread;

    var PorterStatus   = ns.startrek.port.PorterStatus;
    var BaseConnection = ns.startrek.socket.BaseConnection;
    var StarPorter     = ns.startrek.StarPorter;

    var BaseSession         = ns.network.BaseSession;
    var SessionStateMachine = ns.network.SessionStateMachine;

    /**
     *  Session for Connection
     *  ~~~~~~~~~~~~~~~~~~~~~~
     *
     *  'key' - Session Key
     *          A random string generated by station.
     *          It will be set after handshake success.
     *
     *   'ID' - Local User ID
     *          It will be set before connecting to remote station.
     *          When it's empty, the session state would be 'Default'.
     *
     *   'active' - Session Status
     *          It will be set to True after connected to remote station.
     *          When connection broken, it will be set to False.
     *          Only send message when it's True.
     *
     *   'station' - Remote Station
     *          Station with remote IP & port, its ID will be set
     *          when first handshake responded, and we can trust
     *          all messages from this ID after that.
     */
    var ClientSession = function (db, server) {
        BaseSession.call(this, db, server.getHost(), server.getPort());
        this.__station = server;  // Station
        this.__fsm = new SessionStateMachine(this);
        this.__key = null;        // String: session key
        this.__accepted = false;
        this.__thread = null;     // Thread
    };
    Class(ClientSession, BaseSession, null, {

        getStation: function () {
            return this.__station;
        },

        getState: function () {
            var fsm = this.__fsm;
            var state = fsm.getCurrentState();
            if (state) {
                return state;
            }
            return fsm.getDefaultState();
        },

        // Override
        setActive: function (flag, when) {
            if (!flag) {
                this.__accepted = false;
            }
            return BaseSession.prototype.setActive.call(this, flag, when);
        },

        isAccepted: function () {
            return this.__accepted;
        },
        setAccepted: function (flag) {
            this.__accepted = flag;
        },

        // Override
        getSessionKey: function () {
            return this.__key;
        },

        setSessionKey: function (sessionKey) {
            this.__key = sessionKey;
        },

        isReady: function () {
            return this.isActive() && this.isAccepted()
                && this.getIdentifier() && this.getSessionKey();
        },

        getConnection: function () {
            var gate = this.getGate();
            var remote = this.getRemoteAddress();
            var docker = gate.getPorter(remote, null);
            if (docker instanceof StarPorter) {
                return docker.getConnection();
            }
            return null;
        },

        /**
         *  State Machine
         */

        getConnectionStateMachine: function () {
            var conn = this.getConnection();
            if (conn instanceof BaseConnection) {
                return conn.getStateMachine();
            }
            return null;
        },

        pause: function () {
            var sess_machine = this.__fsm;
            var conn_machine = this.getConnectionStateMachine();
            sess_machine.pause();
            conn_machine.pause();
        },

        resume: function () {
            var sess_machine = this.__fsm;
            var conn_machine = this.getConnectionStateMachine();
            conn_machine.resume();
            sess_machine.resume();
        },

        // Override
        setup: function () {
            this.setActive(true, 0);
            return BaseSession.prototype.setup.call(this);
        },

        // Override
        finish: function () {
            this.setActive(false, 0);
            return BaseSession.prototype.finish.call(this);
        },

        // // Override
        // createHub: function (delegate, remote) {
        //     var hub = new ClientHub(delegate);
        //     // var conn = hub.connect(remote, null);
        //     // TODO: reset send buffer size
        //     return hub;
        // },

        // Override
        onPorterStatusChanged: function (previous, current, docker) {
            //BaseSession.prototype.onPorterStatusChanged.call(this, previous, current, docker);
            if (!current || PorterStatus.ERROR.equals(current)) {
                // connection error or session finished
                // TODO: reconnect?
                this.setActive(false, 0);
                // TODO: clear session ID and handshake again
            } else if (PorterStatus.READY.equals(current)) {
                // connected/reconnected
                this.setActive(true, 0);
            }
        },

        // Override
        onPorterReceived: function (arrival, docker) {
            //BaseSession.prototype.onPorterReceived.call(this, arrival, docker);
            var all_responses = [];
            var messenger = this.getMessenger();
            // 1. get data packages from arrival ship's payload
            var packages = get_data_packages(arrival);
            var pack;
            var responses;
            var res;
            for (var i = 0; i < packages.length; ++i) {
                pack = packages[i];
                try {
                    // 2. process each data package
                    responses = messenger.processPackage(pack);
                    if (!responses || responses.length === 0) {
                        continue;
                    }
                    for (var j = 0; j < responses.length; ++j) {
                        res = responses[j];
                        if (!res || res.length === 0) {
                            // should not happen
                            continue;
                        }
                        all_responses.push(res);
                    }
                } catch (e) {
                    Log.error('ClientSession::onPorterReceived()', e, pack);
                }
            }
            var gate = this.getGate();
            var source = docker.getRemoteAddress();
            var destination = docker.getLocalAddress();
            // 3. send responses separately
            for (var k = 0; i < all_responses.length; ++k) {
                gate.sendResponse(all_responses[k], arrival, source, destination);
            }
        }
    });

    var force_stop = function () {
        var thread = this.__thread;
        if (thread) {
            this.__thread = null;
            thread.stop();
        }
    };
    /// start session in background thread
    /// start session state machine
    ClientSession.prototype.start = function (delegate) {
        force_stop.call(this);
        // start a background thread
        var thread = new Thread(this);
        thread.start();
        this.__thread = thread;
        // start state machine
        var fsm = this.__fsm;
        fsm.setDelegate(delegate);
        fsm.start();
    };
    // Override
    ClientSession.prototype.stop = function () {
        //GateKeeper.prototype.stop.call(this);
        BaseSession.prototype.stop.call(this);
        force_stop.call(this);
        var fsm = this.__fsm;
        fsm.stop();
    };

    var get_data_packages = function (arrival) {
        var payload = arrival.getPayload();
        // check payload
        if (!payload || payload.length === 0) {
            return [];
        } else if (payload[0] === jsonStart) {
            // JsON in lines
            return split_packages(payload);
        } else {
            // TODO: other format?
            return [payload];
        }
    };
    var jsonStart = '{'.charCodeAt(0);

    var split_packages = function (payload) {
        // return payload.split('\n'.charCodeAt(0));
        var array = [];
        var i, j = 0;
        for (i = 1; i < payload.length; ++i) {
            if (payload[i] !== NEW_LINE) {
                continue;
            }
            if (i > j) {
                array.push(payload.slice(j, i));
            }
            j = i + 1;  // skip '\n'
        }
        if (i > j) {
            array.push(payload.slice(j, i));
        }
        return array;
    };
    var NEW_LINE = '\n'.charCodeAt(0);

    //-------- namespace --------
    ns.network.ClientSession = ClientSession;

})(DIMP);
